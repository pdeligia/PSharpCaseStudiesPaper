The goal of our work is to develop testing techniques for detecting and debugging Heisenbugs in distributed storage systems prior to deployment. To achieve our goal, we use \psharp~\cite{deligiannis2015psharp}, an extension of the mainstream \csharp language that provides: (i) language support for \emph{modeling the environment} of distributed systems developed using Microsoft's .NET framework; and (ii) a \emph{testing engine} that can systematically explore all interleavings between asynchronous event handlers, as well as other nondeterministic events such as failures and timeouts.

A \psharp program consists of multiple \emph{state machines} that communicate with each other \emph{asynchronously} by sending and receiving \emph{events}, which may contain an optional \emph{payload}. A \psharp machine declaration is similar to a class declaration in \csharp: it can contain an arbitrary number of fields and methods. However, a machine declaration differs from a class declaration, as it also contains an input event queue, and one or more \emph{states}. Each state can register \emph{actions} to handle incoming events.

\psharp machines run concurrently with each other, each executing an event handling loop that dequeues an event from the input queue and handles it by invoking the registered action. This action might access a field, call a method, transition the machine to a new state, create a new machine, or send an event to another machine. In \psharp, a send operation is \emph{non-blocking}; the event is simply enqueued into the input queue of the target machine, which will dequeue and handle the event concurrently. All this functionality is provided in a lightweight runtime library, built on top of Microsoft's Task Parallel Library~\cite{leijen2009tpl}.

Our approach of using \psharp to test distributed systems, implemented in .NET, requires the developer to perform the following three key modeling tasks. These tasks are illustrated in \S\ref{sec:method} for the Azure Storage vNext system.

\begin{enumerate}
\item The real components of a distributed system must be wrapped inside \psharp machines. In addition, all the asynchrony due to message passing in the system must be modeled using the \psharp event-sending APIs. 

\item The environment of the system must be modeled using \psharp. \psharp offers APIs for obtaining non-deterministically chosen values, which can be used to simulate failures, timers, etc. (see \S\ref{sec:method:driver}). This step captures external sources of nondeterminism. \psharp's testing engine can then systematically explore all choices, enumerating different asynchronous event interleavings, possible points of failures, timers firing, etc. (see \S\ref{sec:psharp:testing}).

\item The criteria for correctness of an execution must be specified. Specifications in \psharp can encode either \emph{safety} or \emph{liveness}~\cite{lamport1977proving} properties (see \S\ref{sec:bg:bugs}). Safety specifications generalize the notion of source code assertions; a safety violation is a finite trace leading to an erroneous state. Liveness specifications generalize nontermination; a liveness violation is an infinite trace that exhibits lack of progress.

%\item Likewise, all other sources of nondeterminism, such as failures and timer expiration, must be modeled using appropriate \psharp APIs. This step allows \psharp to systematically explore all asynchronous event handler interleavings and all other sources of nondeterminism during testing (see \S\ref{sec:psharp:testing}).
\end{enumerate}

\noindent
We collectively refer to the environment model of a system and its wrapped components as the \psharp \emph{test harness}. This test harness can be used by \psharp to drive the system towards interesting behaviors.
\psharp uses modern object-oriented language features such as \emph{interfaces} and \emph{virtual method dispatch} to connect the real code with the modeled code. Programmers in industry are used to working with such features, and heavily use them in production for testing purposes. In our experience, this significantly lowers the bar for product teams inside Microsoft to embrace \psharp for testing.

In principle, our modeling methodology is \emph{not specific} to \psharp and the .NET framework, and can be used in combination with any other programming framework that has equivalent capabilities. We also argue that our approach is \emph{flexible} since it allows the user to model \emph{as much} or \emph{as little} of the environment as required to achieve the desired level of testing.

\subsection{Specifications}
\label{sec:bg:bugs}

In  this section, we describe how safety and liveness specifications are expressed in \psharp.

\textbf{Safety specifications}.
In addition to the usual assertions for stating safety properties that are local to a machine, \psharp also provides a way to specify global assertions by using a \emph{safety monitor}~\cite{desai2015building}, which is a special machine that can receive, but not send, events.

A safety monitor maintains local state that is modified in response to events received from ordinary (non-monitor) machines. This local state is used to maintain a history of the computation that is relevant to the property being specified. An erroneous global behavior is flagged via an assertion on the private state of the safety monitor. Thus, a \psharp monitor cleanly separates instrumentation state required for specification (inside the monitor) from program state (outside the monitor).

\textbf{Liveness specifications}.
Liveness property specifications are more difficult to encode since they are intended to capture program progress over infinite executions. Violation of a liveness property can only be demonstrated by an infinite execution. Usually, a liveness property is specified via a temporal logic formula~\cite{Pnueli1977,lamport1994temporal}. We take a different approach and allow the programmer to write a \emph{liveness monitor}~\cite{desai2015building}. Similar to a safety monitor, a liveness monitor can receive, but not send, events. Unlike a safety monitor, a liveness monitor contains two types of states: \emph{hot} and \emph{cold}.

A hot state denotes a point in the execution where progress is required but has not happened yet; for example, a node has failed but a new one has not come up yet. A liveness monitor enters a hot state upon receiving notification of an event that requires the system to make progress. The liveness monitor leaves the hot state and enters a cold state upon receiving another event notifying it of progress. An infinite execution is erroneous if the liveness monitor is in a hot state infinitely often but in a cold state only finitely often. Our liveness monitors can encode arbitrary temporal logic properties. A thermometer analogy is useful for understanding liveness monitors: a hot state increases the temperature by a small value; a cold state resets the temperature to zero; a liveness error happens if the temperature becomes infinite.
%The distinction between ordinary and cold states is useful for modeling progress for each instance of an infinite stream of events, such as a periodic request or a periodic timer expiration.

A liveness violation is witnessed by an \emph{infinite} execution in which all concurrently executing \psharp machines are \emph{fairly} scheduled. Unfortunately, it is clearly not possible to generate an infinite execution by executing a program for a finite amount of time. Therefore, our implementation of liveness checking in \psharp approximates an infinite execution using several heuristics. One such heuristic considers an execution longer than a large user-supplied bound as an ``infinite'' execution~\cite{killian2007life, musuvathi2008fair}. Another heuristic maintains a cache of (pieces of) the state of the \psharp program obtained at each step in the execution, and reports an ``infinite'' execution when the latest step results in a cache hit, thus approximating a cycle in the state graph of the program.

%\textbf{Using monitors}.
%To declare a safety or a liveness monitor, the programmer must inherit from the \psharp \texttt{Monitor} class. \psharp monitors are singleton instances and, thus, an ordinary machine does not need a reference to a monitor to send it an event. Instead, an ordinary machine can invoke a monitor by calling \texttt{Monitor<M>(e, p)}, where the parameter \texttt{e} is the event being send, and the parameter \texttt{p} is an optional payload.

\subsection{Systematic testing}
\label{sec:psharp:testing}

The \psharp runtime is a lightweight layer build on top of the Task Parallel Library (TPL) of .NET that implements the semantics of \psharp: creating state machines, executing them concurrently using the default task scheduler of TPL, and sending events and enqueueing them in the appropriate machines. A key capability of the \psharp runtime is that it can execute in \emph{bug-finding} mode, which systematically tests a \psharp program to find bugs using the safety and liveness monitors that were discussed in \S\ref{sec:bg:bugs}.

When the \psharp runtime executes in bug-finding mode, an embedded \emph{systematic concurrency testing engine}~\cite{godefroid1997verisoft, musuvathi2008finding, emmi2011delay} captures and takes control of all sources of non-determinism that are \emph{known} to the \psharp runtime. In particular, the runtime is aware of nondeterminism due to the interleaving of event handlers in different machines. Each send operation to an ordinary (non-monitor) machine, and each create operation of an ordinary machine, creates an interleaving point where the runtime makes a scheduling decision. The runtime is also aware of all nondeterministic events (e.g. failures) that were captured during the modeling process.

The \psharp testing engine will repeatedly execute a program from start to completion, each time exploring a potentially different set of scheduling decisions, until it either reaches a bound (in number of iterations or time), or it hits a property violation. This testing process is fully automatic, has no false-positives (assuming an accurate environment model), and can reproduce found bugs by replaying buggy schedules. After a bug is found, the engine generates a trace that represents the buggy schedule. In contrast to logs typically generated during production, the \psharp trace provides a global order of all communication events and, thus, is easier to debug.

We have implemented two different schedulers inside the \psharp systematic testing engine: a \emph{random} scheduler that makes each nondeterministic choice randomly, and a \emph{probabilistic concurrency testing}~\cite{burckhardt2010pct} (PCT) scheduler. It is straightforward to create a new scheduler by implementing the \texttt{ISchedulingStrategy} interface~\cite{desai2015systematic} exposed by the \psharp libraries. The interface exposes callbacks that are invoked by the \psharp testing engine for taking decisions regarding which machine to schedule next, and can be used for developing both generic and application-specific schedulers.

\textbf{Handling \csharp 5.0 asynchrony}.
Our case studies heavily use the \texttt{async} and \texttt{await} \csharp 5.0 language primitives. An \texttt{async} method is able to perform \texttt{await} on a TPL task \emph{without} blocking the current thread. The \csharp compiler achieves this non-blocking behavior by wrapping the code following an \texttt{await} statement in a TPL \emph{task continuation}, and then returning execution to the caller of the \texttt{async} method. The TPL scheduler executes this task continuation when the task being awaited has completed. In principle, this asynchrony can be modeled using the \psharp primitives for machine creation and message passing. However, in our experience, modeling async/await asynchronous code using \psharp is difficult and time consuming, and thus infeasible for large code bases. To tackle this problem, we developed a solution that automatically captures asynchronously created TPL tasks and wraps them in temporary \psharp machines.

%The \texttt{async} and \texttt{await} \csharp 5.0 primitives were not originally supported in \psharp. To be able to test our case studies, as well as other systems written in \csharp 5.0, we had to extend \psharp with support for intra-machine concurrency (see \S\ref{sec:psharp:testing}).

Our solution involves using a \emph{custom task scheduler}, during systematic testing with \psharp, instead of the default TPL scheduler.
%Assuming that the developer does not explicitly change the task scheduler (something extremely uncommon),
All TPL tasks spawned in the \psharp program will be scheduled for execution in the \psharp task scheduler. These tasks will be intercepted by our custom task scheduler and wrapped inside a special (not available to the programmer) task-machine. When the \psharp testing engine schedules a task-machine for execution, the corresponding task is unwrapped and executed. This approach works nicely with the \texttt{async} and \texttt{await} \csharp 5.0 primitives: when an \texttt{async} method is called, the asynchronous TPL task will be automatically wrapped in a task-machine and scheduled by \psharp; for \texttt{await}, no special treatment is required since the task continuation will also be automatically wrapped and scheduled accordingly.
