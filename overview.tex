The goal of our work is to develop testing techniques to detect and debug Heisenbugs in distributed storage systems prior to deployment.
To achieve our goal, we use \psharp~\cite{deligiannis2015psharp}, a framework that provides: (i) an \emph{event-driven asynchronous programming} language for developing and modeling distributed systems; and (ii) a \emph{systematic concurrency testing} engine that can systematically explore all interleavings between asynchronous event handlers, as well as other nondeterministic events such as failures and timeouts.

A \psharp program consists of multiple \emph{state machines} that communicate with each other \emph{asynchronously} by sending and receiving \emph{events}, which may contain an optional \emph{payload}. A \psharp machine is similar to a class in \csharp: it can contain any number of fields and methods, but it also contains an input event queue, and one or more states. Each state can register \emph{actions} to handle incoming events. \psharp machines run concurrently with each other, each executing an event handling loop that dequeues an event from the input queue and handles it by invoking the registered action. This action might access a field, call a method, transition the machine to a new state, create a new machine, or send an event to another machine. In \psharp, a send operation is non-blocking; the event is simply enqueued into the input queue of the target machine, and it is up to the operating system scheduler to decide when to dequeue an event and handle it. All this functionality is provided in a lightweight runtime library, build on top of Microsoft's Task Parallel Library~\cite{leijen2009tpl}.

Our approach of using \psharp to test distributed systems, implemented in the .NET framework, requires the developer to perform the following three key modeling tasks. These tasks are illustrated in Section~\ref{sec:method} using the Azure Storage vNext as a running example.

\begin{enumerate}
\item
The computation model underlying \psharp is communicating state machines. The environment of the system-under-test must be modeled using the \psharp APIs, while the real components of the system must be wrapped inside \psharp machines. We call this modeled environment the \psharp test harness.

\item
All the asynchrony due to message passing between system components must become explicit and be modeled using the \psharp event-sending APIs. Similarly, all other sources of nondeterminism (e.g. failures and timer expiration) must be modeled using appropriate \psharp APIs. This step allows the \psharp runtime to systematically explore all asynchronous event handler interleavings and all other sources of nondeterminism during testing.

\item
The criteria for correctness of an execution must be specified. Specifications in \psharp can encode either \emph{safety} or \emph{liveness}~\cite{lamport1977proving} properties. Safety specifications generalize the notion of source code assertions; a safety violation is a finite trace leading to an erroneous state. Liveness specifications generalize nontermination; a liveness violation is an infinite trace that exhibits lack of progress.
\end{enumerate}

\noindent
\psharp uses modern languages features such as \emph{interfaces} and \emph{virtual method dispatch} to connect the real code with the modeled code. Programmers in industry are used to work with such features, and heavily use them in production for testing purposes. In our experience, this significantly lowers the bar for product teams inside Microsoft to embrace \psharp for testing.

In principle, our modeling methodology is \emph{not specific} to \psharp and the .NET framework, and can be used in combination with any other programming framework that has equivalent capabilities. We also argue that our approach is \emph{flexible} since it allows the user to model \emph{as much} or \emph{as little} of the environment as required to achieve the desired level of testing.

\subsection{Specifications}
\label{sec:bg:bugs}

In  this section, we describe how safety and liveness specifications are expressed in \psharp.

\textbf{Safety specifications}.
In addition to the usual assertions that can be used to write safety properties that are local to a machine, \psharp also provides a way to specify global assertions by using a \emph{safety monitor}~\cite{desai2015building}, which is a special machine that can receive, but not send, events. A safety monitor maintains local state that is modified in response to events received from ordinary (non-monitor) machines. This local state is used to maintain a history of the computation that is relevant to the property being specified. An erroneous global behavior is flagged via an assertion on the private state of the safety monitor. 
Thus, a monitor cleanly separates instrumentation state required for specification (inside the monitor) from program state (outside the monitor).

To declare a monitor, the programmer inherits from the \psharp \texttt{Monitor} class. Monitors in \psharp are singleton instances, which means that an ordinary machine does not need a reference to a monitor to send it an event. An ordinary machine can send an event to a monitor by calling \texttt{Monitor<M>(e, p)}, where the parameter \texttt{e} is the event being send together with an optional payload \texttt{p}.

\textbf{Liveness specifications}.
Liveness property specifications are more difficult to encode since they are intended to capture program progress
over infinite executions.
Violation of a liveness property can only be demonstrated by an infinite execution.
Usually, a liveness property is specified via a temporal logic formula~\cite{Pnueli1977,lamport1994temporal}.
We take a different approach and allow the programmer to write a \emph{liveness monitor}.
Similar to a safety monitor, a liveness monitor receives events but does not send them.
Unlike a safety monitor, a liveness monitor~\cite{desai2015building}
contains three types of states---\emph{ordinary}, \emph{hot}, and \emph{cold}.
A hot state denotes a point in the execution where progress is required but has not happened yet,
e.g., a node has failed but a new one has not come up yet.
A liveness monitor enters a hot state upon receiving notification of an event that requires the system
to make progress and leaves the hot state upon receiving another event notifying it of progress.
An infinite execution is erroneous if the liveness monitor is in a hot state infinitely often but in a cold state only finitely often.
Our liveness monitors can encode arbitrary temporal logic properties.

A thermometer analogy is useful for understanding a liveness monitor.
A hot state increases the temperature by a small value.
A cold state resets the temperature to zero.
A liveness error happens if the temperature becomes infinite.
%The distinction between ordinary and cold states is useful for modeling progress for each instance of an infinite stream of events,
%such as a periodic request or a periodic timer expiration.

A liveness violation is witnessed by an infinite execution in which all concurrently executing \psharp machines are scheduled fairly.
Unfortunately, it is clearly not possible to generate an infinite execution by executing a program for a finite amount of time.
Therefore, our implementation of liveness checking approximates an infinite execution using several heuristics.
One heuristic considers an execution longer than a large user-supplied bound as an ``infinite'' execution~\cite{killian2007life, musuvathi2008fair}.
Another heuristic maintains a cache of (pieces of) the state of the \psharp program obtained at each step in the execution
and reports an ``infinite'' execution when the latest step results in a cache hit, thus approximating a cycle in the state
graph of the program.

\subsection{Systematic testing}
\label{sec:psharp:testing}

The \psharp runtime is a lightweight layer build on top of the Task Parallel Library (TPL) of .NET that implements the semantics of \psharp: creating state machines, executing them concurrently using the default task scheduler of TPL, and sending events and enqueueing them in the appropriate machines. A key capability of the \psharp runtime is that it can execute in bug-finding mode, which systematically tests a \psharp program to find bugs using the safety and liveness monitors that were discussed in Section~\ref{sec:bg:bugs}.

When the \psharp runtime executes in bug-finding mode, an embedded \emph{systematic concurrency testing engine}~\cite{godefroid1997verisoft, musuvathi2008finding, emmi2011delay} captures and takes control of all sources of non-determinism that are \emph{known} to the \psharp runtime. In particular, the runtime is aware of nondeterminism due to the interleaving of event handlers in different machines. Each send operation to an ordinary (non-monitor) machine, and each create operation of an ordinary machine, creates an interleaving point where the runtime makes a scheduling decision. The runtime is also aware of all nondeterministic events (e.g. failures) that were captured during the modeling process.

The \psharp systematic testing engine will repeatedly execute a program from start to completion, each time exploring a potentially different set of scheduling decisions, until it either reaches a bound (in number of iterations or time), or it hits a property violation. This testing process is fully automatic, has no false-positives (assuming an accurate environmental model), and can reproduce found bugs by replaying buggy schedules. After a bug is found, the engine generates a trace that represents the buggy schedule. In contrast to logs typically generating during production, this log provides a global order of all communication events and, thus, is easier to debug.

We have implemented two different schedulers inside the \psharp systematic testing engine: a \emph{random} scheduler that makes each nondeterministic choice randomly and a \emph{probabilistic concurrency testing}~\cite{burckhardt2010pct} (PCT) scheduler. It is straightforward to create a new scheduler by implementing the \texttt{ISchedulingStrategy} interface~\cite{desai2015systematic} exposed by the \psharp libraries. The interface exposes callbacks that are invoked by the \psharp runtime for taking decisions regarding which machine to schedule next, and can be used for developing both generic and application-specific schedulers.

\subsubsection{Handling \csharp 5.0 asynchrony}
\label{sec:psharp:async}

The Live Azure Migration system (Section~\ref{sec:cases:migration}) uses the \texttt{async} and \texttt{await} \csharp 5.0 language primitives.
An \texttt{async} procedure is allowed to perform \texttt{await} on a TPL task without blocking the current thread.
The \csharp compiler achieves this non-blocking behavior by wrapping the \emph{continuation} of the \texttt{await} statement
in a TPL task and returning it to the caller.
The TPL scheduler executes this task when the task being awaited has completed.
In principle, this asynchrony can be modeled using the \psharp primitives for machine creation and message passing.
However, in our experience, refactoring code to model in \psharp the asynchrony in async/await is difficult and unlikely
to scale for large code bases.
Therefore, our implementation automatically captures asychronously created tasks in .NET runtime as \psharp machines.

Our solution involves using a custom task scheduler whenever the bug-finding mode of the \psharp runtime is enabled, instead of the default TPL task scheduler. The \psharp task scheduler inherits from the \texttt{TaskScheduler} class, a low-level API that is responsible for enqueueing TPL tasks into threads. Our approach works as follows. We start the task of the \emph{root} \psharp machine in our custom task scheduler. As long as any child tasks spawned by the root machine task do not explicitly start in another scheduler (including the default TPL scheduler), then they will be scheduled for execution in our custom task scheduler. Our custom scheduler intercepts the call to enqueue a task, creates a special machine (only internally available to \psharp) called \texttt{TaskMachine} and \emph{wraps} the enqueued task inside this machine. The constructor of a \texttt{TaskMachine} takes as an argument a TPL task and stores it in an field. The \texttt{TaskMachine} has only a single state and when it is scheduled for execution by the \psharp systematic testing scheduler it starts executing the wrapped task and then immediately waits on its completion. This forces the lifetime of the task to become the lifetime of the machine and vice versa. Thus, when the \psharp systematic testing scheduler schedules the \texttt{TaskMachine}, it will also schedule the corresponding task. This means that when a \psharp program makes a call to an \texttt{async} method, then the task created in the backend will be automatically wrapped and scheduled.

For \texttt{await} statements, no special treatment is required because \texttt{await} statements are compiled into a continuation. The task associated with the continuation will also be wrapped and scheduled accordingly.
