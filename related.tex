Most related to our work are model checking~\cite{godefroid1997verisoft} and systematic concurrency testing~\cite{musuvathi2008finding, emmi2011delay, thomson2014sct}, two powerful techniques that have been widely used in the past for finding Heisenbugs in the actual implementation of distributed systems~\cite{killian2007life, yang2009modist, yabandeh2009crystalball, guerraoui2011model, guo2011practical, simsa2011dbug, gunawi2011fate, leesatapornwongsa2014samc}.

State-of-the-art model checkers, such as \textsc{MoDist}~\cite{yang2009modist} and dBug~\cite{simsa2011dbug}, typically focus on testing entire, often \emph{unmodified}, distributed systems, an approach that easily leads to state-space explosion. \textsc{DeMeter}~\cite{guo2011practical}, built on top of \textsc{MoDist}, aims to reduce the state-space when exploring unmodified distributed systems. \textsc{DeMeter} explores individual components of a large system in isolation, and then dynamically extracts interface behavior between components to perform a global exploration. In contrast, we try to offer a more pragmatic approach for handling state-space explosion. We first \emph{partially} model a distributed system using \psharp. Then, we systematically test the actual implementation of each system component against its \psharp test harness. Our approach aims to enhance unit and integration testing, techniques widely used in production, where only individual or a small number of components are tested at each time.

SAMC~\cite{leesatapornwongsa2014samc} offers a way of incorporating application-specific information during systematic testing to reduce the set of interleavings that the tool has to explore. Such techniques based on partial-order reduction~\cite{godefroid1996partial, flanagan2005dynamic} are complementary to our approach: \psharp could use them to reduce the exploration state-space. Likewise, other tools can use language technology like \psharp to write models and reduce the complexity of the system-under-test.

\textsc{MaceMc}~\cite{killian2007life} is a model checker for distributed systems written in the \textsc{Mace}~\cite{killian2007mace} language. The focus of \textsc{MaceMc} is to find liveness property violations using an algorithm based on depth-bounded random walk and the use of heuristics. Because \textsc{MaceMc} can only test systems written in \textsc{Mace}, it cannot be easily used in an industrial setting. In contrast, \psharp can be applied on legacy code written in \csharp, a mainstream language.

%\textsc{Fate} and \textsc{Destini} is a framework for systematically injecting failures in distributed systems~\cite{gunawi2011fate}. This framework focuses in exercising various failure scenarios, whereas \psharp can be used for testing generic safety and liveness properties of distributed systems.

Formal methods have been successfully used in industry to verify the correctness of distributed protocols. A recent notable example is the use of TLA+~\cite{lamport1994temporal} by the Amazon Web Services team~\cite{newcombe2015aws}. TLA+ is an expressive formal specification language that can be used to design and verify concurrent programs via model checking. A limitation of TLA+, as well as other similar specification languages, is that they are applied on a model of the system and not the actual system. Even if the model is verified, the gap between the real-world implementation and the verified model is still significant, so implementation bugs are still a realistic concern.

Another formal approach is Verdi~\cite{wilcox2015verdi}, a framework for writing and verifying distributed systems in Coq~\cite{barras1997coq}. Verdi generates OCaml code from the verifying system, which can be used for execution. In contrast, \psharp performs bounded testing on a system already written in \csharp, which in our experience lowers the bar for adoption by engineering teams. Verdi does not currently support detecting liveness property violations, an important class of bugs in distributed storage systems.
