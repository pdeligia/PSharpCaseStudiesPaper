Model checking~\cite{godefroid1997verisoft} is a powerful technique that has been widely used in the past for finding tricky bugs in the actual implementation of distributed systems~\cite{killian2007life, yang2009modist, yabandeh2009crystalball, guerraoui2011model, guo2011practical, simsa2011dbug, leesatapornwongsa2014samc}. 

State-of-the-art model checkers, such as \textsc{MoDist}~\cite{yang2009modist} and dBug~\cite{simsa2011dbug}, typically focus on testing entire, often unmodified, distributed systems, an approach that easily leads to state-space explosion. In contrast, we try to offer a more pragmatic approach for handling state-space explosion: \psharp provides the capability for creating models of individual components of a large system, which helps towards component isolation and enables compositional testing. Our approach aims to enhance unit and integration testing, techniques widely used in production, where only individual (or a small number of) components are tested at each time.

Tools such as CrystalBall~\cite{yabandeh2009crystalball} and \textsc{DeMeter}~\cite{guo2011practical} employ techniques based on dynamic partial order reduction~\cite{lauterburg2010evaluating} to reduce the exploration state-space. The SAMC~\cite{leesatapornwongsa2014samc} model checker offers a way of incorporating application-specific information during systematic testing to reduce the set of interleavings that the tool has to explore. These techniques are complementary to our approach: the \psharp systematic testing engine could use them for reducing the number of interleavings it explores, just as the other tools can use language technology (like \psharp) to write models and reduce the complexity of the system-under-test. 

% Further, note that we operate at a different scale by focusing on compositional testing. For instance, SAMC reports orders of magnitude speedup over previous testing techniques, but executing 100,000 runs still took ``approximately 48 full machine days''~\cite{leesatapornwongsa2014samc}. In our case studies, we execute a similar number of iterations in a matter of hours, and find serious bugs in seconds (see \S\ref{sec:eval}). This does \emph{not} imply that \psharp is faster (nor we attempt to make that claim); but simply that we explore behaviors at a different level.

%as aforementioned, we focus on compositional testing, whereas prior work typically focuses on testing an entire system. %We are just trying to solve a similar problem at a very different level.

\textsc{MaceMc}~\cite{killian2007life} is a model checker for distributed systems implemented in the \textsc{Mace} language. The focus of \textsc{MaceMc} is to find liveness property violations using an algorithm based on bounded random walk and the use of heuristics. \psharp differs from \textsc{MaceMc} in that it can be applied on legacy code written in a mainstream language, whereas a system to be tested with \textsc{MaceMc} has to be written in \textsc{Mace}, which makes \textsc{MaceMc} harder to be applied in an industrial setting.

\textsc{Fate} and \textsc{Destini} is a framework for systematically injecting (combination of) failures in distributed systems~\cite{gunawi2011fate}. This framework focuses in exercising failure scenarios, whereas \psharp can be used for testing generic safety and liveness properties of distributed systems. \psharp also provides language extensions and modeling capabilities that further differentiate it from prior work.

Formal methods have been successfully used in industry to verify the correctness of distributed protocols. A recent notable example is the use of TLA+~\cite{lamport1994temporal} by the Amazon Web Services team~\cite{newcombe2015aws}. TLA+ is an expressive formal specification language that can be used to design and verify concurrent programs via model checking. A limitation of TLA+, as well as other similar specification languages, is that they are applied on a model of the system and not the actual system. Even if the model is verified, the gap between the real-world implementation and the verified model is still significant, so implementation bugs are still a realistic concern.

Another formal approach is Verdi~\cite{wilcox2015verdi}, a framework for writing and verifying distributed systems in Coq~\cite{barras1997coq}. Verdi generates OCaml code from the verifying system, which can be used for execution. In contrast, \psharp performs bounded testing on a system already written in \csharp, which in our experience lowers the bar for adoption by engineering teams. Verdi does not currently support detecting liveness property violations, an important class of bugs in distributed storage systems.
