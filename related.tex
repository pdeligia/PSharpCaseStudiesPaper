Model checking~\cite{godefroid1997verisoft} is a powerful technique that has been widely used in the past for finding tricky bugs in the actual implementation of distributed systems~\cite{killian2007life, yang2009modist, yabandeh2009crystalball, guerraoui2011model, guo2011practical, simsa2011dbug, leesatapornwongsa2014samc}. 

State-of-the-art model checkers, such as \textsc{MoDist}~\cite{yang2009modist} and dBug~\cite{simsa2011dbug}, typically focus on testing entire, often unmodified, distributed systems, an approach that easily leads to state-space explosion. In contrast, we try to offer a more pragmatic approach for handling state-space explosion: \psharp provides the capability for creating models of individual components of a large system, which helps towards component isolation and enables compositional testing. Our approach aims to enhance unit and integration testing, techniques widely used in production, where only individual (or a small number of) components are tested at each time.

Tools such as CrystalBall~\cite{yabandeh2009crystalball} and \textsc{DeMeter}~\cite{guo2011practical} employ techniques based on dynamic partial order reduction~\cite{lauterburg2010evaluating} to reduce the exploration state-space. The SAMC~\cite{leesatapornwongsa2014samc} model checker offers a way of incorporating application-specific information during systematic testing, but the focus is still on reducing the set of possible interleavings. Although SAMC is orders of magnitude faster than previous testing techniques, the authors mention that their ``extensive evaluation exercised more than 100,000 executions and used approximately 48 full machine days''~\cite{leesatapornwongsa2014samc}. \psharp is able to explore a similar number of iterations in a matter of hours, and find serious bugs in seconds (see \S\ref{sec:eval}). However, we do \emph{not} claim that \psharp is faster; as aforementioned, we focus on compositional testing, whereas prior work typically focuses on testing an entire system. We are just trying to solve a similar problem at a very different level.

\textsc{MaceMc}~\cite{killian2007life} is a model checker for distributed systems implemented in the \textsc{Mace} language. The focus of \textsc{MaceMc} is to find liveness property violations using an algorithm based on bounded random walk and the use of heuristics. \psharp differs from \textsc{MaceMc} in that it can be applied on legacy code written in a mainstream language, whereas a system to be tested with \textsc{MaceMc} has to be written in \textsc{Mace}, which makes \textsc{MaceMc} harder to be applied in an industrial setting.

\textsc{Fate} and \textsc{Destini} is a framework for systematically injecting (combination of) failures in distributed systems~\cite{gunawi2011fate}. This framework focuses in exercising failure scenarios, whereas \psharp can be used for testing generic safety and liveness properties of distributed systems. \psharp also provides language extensions and modeling capabilities that further differentiate it from prior work.

Formal methods have been successfully used in industry to verify the correctness of distributed protocols. A recent notable example is the use of TLA+~\cite{lamport1994temporal} by the Amazon Web Services team~\cite{newcombe2015aws}. TLA+ is an expressive formal specification language that can be used to design and verify concurrent programs via model checking. A limitation of TLA+, as well as other similar specification languages, is that they are applied on a model of the system and not the actual system. Even if the model is verified, the gap between the real-world implementation and the verified model is still significant, so implementation bugs are still a realistic concern.

Another formal approach is Verdi~\cite{wilcox2015verdi}, a framework for writing and verifying distributed systems in Coq~\cite{barras1997coq}. Verdi generates OCaml code from the verifying system, which can be used for execution. In contrast, \psharp performs bounded testing on a system already written in \csharp, which in our experience lowers the bar for adoption by product groups. Furthermore, Verdi does not currently support detecting liveness property violations, an important class of bugs in distributed storage systems.
