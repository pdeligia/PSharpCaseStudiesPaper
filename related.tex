\psharp is most closely related to \textsc{MoDist}~\cite{yang2009modist}, a model checker that can be applied on unmodified distributed systems. To achieve this, the tool uses binary instrumentation (reuses the instrumentation engine of the D$^3$S testing tool) to expose all actions of the system-under-test, and then uses a model checking engine to systematically explore these actions. \textsc{MoDist} also provides a virtual clock manager that can simulate timeouts and accelerate the passage of time. A major limitation of \textsc{MoDist} is that it must be applied on a whole system, which does not scale for production systems. In contrast, \psharp has built-in support for modeling the environment of individual components of a system, which allows the tool to achieve scalability. Further, \psharp is an extension of the \csharp language and has built-in systematic testing support; it does not need to perform binary instrumentation which can be computationally expensive.

\textsc{MaceMc}~\cite{killian2007life} is a model checker for distributed systems implemented in the \textsc{Mace} language. The focus of \textsc{MaceMc} is to find liveness property violations using an algorithm based on bounded random walk and the use of heuristics. \psharp differs from \textsc{MaceMc} in that it can be applied on legacy code written in a mainstream language, whereas a system to be tested with \textsc{MaceMc} has to be written in \textsc{Mace}, which makes \textsc{MaceMc} harder to be applied in an industrial setting. Further, \psharp uses a simpler, but effective, algorithm for detecting liveness bugs.

\textsc{Fate} and \textsc{Destini} is a framework for systematically injecting (combination of) failures in distributed systems~\cite{gunawi2011fate}. This framework focuses in exercising failure scenarios, whereas \psharp can be used for testing generic safety and liveness properties of distributed systems. \psharp also provides language extensions and modeling capabilities that further differentiate it from prior work.

A completely different approach for reasoning about the correctness of distributed systems is to use formal methods.  A notable example is TLA+~\cite{lamport1994temporal}, a formal specification language that can be used to design and verify concurrent programs via model checking. Amazon recently published an article describing their use of TLA+ in Amazon Web Services to verify distributed protocols~\cite{newcombe2015aws}. A limitation of TLA+, as well as other similar specification languages, is that they are applied on a model of the system and not the actual system. Even if the model is verified, the gap between a real-world implementation and the verified model is still significant, so implementation bugs are still a realistic concern.

Another relevant approach is Verdi~\cite{wilcox2015verdi}, where a distributed system is written and verified in Coq, and then OCaml code is produced for execution. Verdi cannot find liveness bugs. \psharp is also more production-friendly: it works on \csharp, which is a mainstream language.
