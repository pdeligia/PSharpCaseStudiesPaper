\subsection{Overview}
\label{sec:psharp:overview}

The \psharp runtime is a lightweight layer build on top of the Task Parallel Library (TPL) of .NET that implements the semantics of \psharp: creating state machines, executing them concurrently using the default task scheduler of TPL, and sending events and enqueueing them in the appropriate machines. A key capability of the \psharp runtime is that it can execute in bug-finding mode for systematically testing a \psharp program to find bugs, such as assertion violations and uncaught exceptions. We now give an overview of how this works, while more details can be found in the original paper~\cite{deligiannis2015psharp}.

The \psharp bug-finding runtime attempts to detect asynchronous bugs by systematically scheduling machines to execute their event handlers in a different order. This approach is based on systematic concurrency testing~\cite{godefroid1997verisoft, musuvathi2008finding, emmi2011delay} (SCT) techniques that have been previously developed for testing shared memory programs. In bug-finding mode, the \psharp runtime serializes the program execution, takes control of the synchronization and nondeterministic choice points, and at each \emph{step} of the execution it invokes a systematically chosen \psharp machine to execute its next event handler. The \psharp runtime will repeatedly execute a program from start to completion, each time exploring a potentially different set of interleavings, until it either reaches a bound (in number of iterations or time), or it hits an assertion failure. The testing is fully automatic, has no false-positives (assuming an accurate environmental model), and can reproduce found bugs by replaying buggy schedules.

We have implemented multiple schedulers inside the \psharp runtime: \emph{random}, \emph{depth-first-search (DFS)}, ..., \emph{PCT}. It is easy to create a new scheduler by implementing the \texttt{ISchedulingStrategy} interface exposed by the \psharp libraries. The interface exposes callbacks that are invoked by the \psharp runtime for taking decisions regarding which machine to schedule next, and can be used for developing both generic and application-specific schedulers, although we have experimented only with generic schedulers so far. Exposing an intuititive interface for creating new schedulers is inspired by previous work~\cite{desai2015tr}.

We designed the bug-finding mode of the \psharp runtime to enable easy debugging: after a bug is found, the runtime can generate a trace that represents the buggy schedule. Note that this trace (in contrast to typical logs generating during production) is sequential.

\subsection{Checking safety specifications}
\label{sec:psharp:safety}

Safety property specifications can be encoded in \psharp by using the provided \texttt{Assert(...)} method. This method takes as argument a predicate, which if evaluates to false denotes a safety property violation. The programmer is also free to use other custom assertion APIs (as \psharp executes actual code), but to enable \psharp to recognize such APIs, the suggested approach is to override them to call the \psharp \texttt{Assert(...)} method.

\psharp also provides a way to specify global assertions by using \emph{monitors}, special state machines that
can only receive events, but not send. A \texttt{Machine} does not need to have a reference to a \texttt{Monitor} to send an event to it, as long as a \texttt{Monitor} has been created, any \texttt{Machine} can invoke it by calling \texttt{Monitor<M>(...)}, where \texttt{M} is the identifier name of the \texttt{Monitor}, and the parameter is event and an optional payload. This call is also synchronous, in contrast to the regular asynchronous \texttt{Send(...)} method calls, as the monitor has to be called deterministically (and not be interleaved).

\subsection{Checking liveness specifications}
\label{sec:psharp:liveness}

Liveness property specifications are in principle harder to encode since they apply over entire program executions instead of individual program states. The \psharp developer can write liveness properties using a \emph{liveness monitor}, which is a special type of monitor that can contain three types of states: regular ones; \emph{hot} states; and \emph{cold} states. A state annotated with the \texttt{Hot} attribute denotes a state where the liveness property is not satisfied (e.g. a node has failed but a new one has not come up yet). A state annotated with the \texttt{Cold} attribute denotes a state where the liveness property is satisfied.

One can imagine a liveness monitor as a \emph{thermometer}: as the program executes and the liveness property is not satisfied, the liveness monitor stays in the hot state, which infinitely raises the temperature. If the liveness property is ever satisfied, and thus the liveness monitor transitions to a cold state, the temperature is instantly reduced to normal levels. Encoding liveness properties using hot and cold states enables the programmer to specify arbitrary LTL properties. The liveness monitors in \psharp are based on previous work~\cite{?}.

\PDComment{Discuss the liveness checking algorithm: are we going to mention the terminating-harness random walk one? or the infinite-harness lasso one with partial caching?}

\subsection{Handling intra-machine concurrency}
\label{sec:psharp:async}

Async/Await

custom schedulers, etc

\subsection{Other}
\label{sec:psharp:other}

Logs/traces -> user can extend them?

\PDComment{mention dependency injection pattern?}
