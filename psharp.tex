The \psharp runtime is a lightweight layer build on top of the Task Parallel Library (TPL) of .NET that implements the semantics of \psharp: creating state machines, executing them concurrently using the default task scheduler of TPL, and sending events and enqueueing them in the appropriate machines. A key capability of the \psharp runtime is that it can execute in bug-finding mode for systematically testing a \psharp program to find bugs, such as assertion violations and uncaught exceptions. We now give an overview of how this works, while more details can be found in the original paper~\cite{deligiannis2015psharp}.

When the \psharp runtime runs in bug-finding mode, an embedded \emph{systematic testing engine} captures and takes control of all sources of non-determinism that are \emph{known} to the \psharp runtime. The engine attempts to detect asynchronous bugs by systematically scheduling machines to execute their event handlers in a different order. This approach is based on systematic concurrency testing~\cite{godefroid1997verisoft, musuvathi2008finding, emmi2011delay} (SCT) techniques that have been previously developed for testing shared memory programs.

The systematic testing engine serializes the program execution, takes control of the synchronization and nondeterministic choice points, and at each \emph{step} of the execution it invokes a systematically chosen \psharp machine to execute its next event handler. The engine will repeatedly execute a program from start to completion, each time exploring a potentially different set of interleavings, until it either reaches a bound (in number of iterations or time), or it hits an assertion failure. The testing is fully automatic, has no false-positives (assuming an accurate environmental model), and can reproduce found bugs by replaying buggy schedules.

We have implemented two schedulers inside the \psharp systematic testing engine: \emph{random} and \emph{probabilistic concurrency testing} (PCT)~\cite{burckhardt2010pct}. The random scheduler takes a completely random decision at every scheduling point, whereas the PCT scheduler uses randomization in a disciplined fashion to provide a probabilistic guarantee of finding a bug. It is straightforward to create a new scheduler by implementing the \texttt{ISchedulingStrategy} interface exposed by the \psharp libraries. The interface exposes callbacks that are invoked by the \psharp runtime for taking decisions regarding which machine to schedule next, and can be used for developing both generic and application-specific schedulers, although we have experimented only with generic schedulers so far. Exposing an easy-to-use interface for creating new schedulers is inspired by previous work~\cite{desai2015tr}.

We designed the systematic testing engine in a way that enables easy debugging: after a bug is found, the engine can generate a trace that represents the buggy schedule. Note that this trace (in contrast to typical logs generating during production) is sequential.

\subsection{Checking safety specifications}
\label{sec:psharp:safety}

Safety property specifications can be encoded in \psharp by using the provided \texttt{Assert(...)} method. This method takes as argument a predicate, which if evaluates to false denotes a safety property violation. The programmer is also free to use other custom assertion APIs (as \psharp executes actual code), but to enable \psharp to recognize such APIs, the suggested approach is to override them to call the \psharp \texttt{Assert(...)} method.

\psharp also provides a way to specify global assertions by using \emph{monitors}, special state machines that
can only receive events, but not send. To declare a monitor, the programmer has to inherit from the \psharp \texttt{Monitor} class. A \texttt{Machine} does not need to have a reference to a \texttt{Monitor} to send an event to it; as long as a \texttt{Monitor} has been created, any \texttt{Machine} can invoke it by calling \texttt{Monitor<M>(...)}, where \texttt{M} is the identifier name of the \texttt{Monitor}, and the parameter is an event and an optional payload. This call is also synchronous, in contrast to the regular asynchronous \texttt{Send(...)} method calls, as the monitor has to be called deterministically (and not be interleaved).

\subsection{Checking liveness specifications}
\label{sec:psharp:liveness}

Liveness property specifications are in principle harder to encode since they apply over entire program executions instead of individual program states. The \psharp developer can write liveness properties using a \emph{liveness monitor}, which is a special type of monitor that can contain three types of states: regular ones; \emph{hot} states; and \emph{cold} states. A state annotated with the \texttt{Hot} attribute denotes a state where the liveness property is not satisfied (e.g. a node has failed but a new one has not come up yet). A state annotated with the \texttt{Cold} attribute denotes a state where the liveness property is satisfied.

One can imagine a liveness monitor as a \emph{thermometer}: as the program executes and the liveness property is not satisfied, the liveness monitor stays in the hot state, which infinitely raises the temperature. If the liveness property is ever satisfied, and thus the liveness monitor transitions to a cold state, the temperature is instantly reduced to normal levels. Encoding liveness properties using hot and cold states enables the programmer to specify arbitrary LTL properties. The liveness monitors in \psharp are based on previous work~\cite{?}.\SCComment{at this point, I realize that our work (perhaps \psharp) doesn't have any symbolic reasoning ingredient in it, right? so the comparison with TLA+ is not an apple-to-apple comparison.} 

\PDComment{Discuss the liveness checking algorithm: are we going to mention the terminating-harness random walk one? or the infinite-harness lasso one with partial caching?}

The liveness property that must be always eventually satisfied in the Azure Storage vNext system is that a user-defined $N$ number of extent nodes must be always eventually available with the latest extent. There was an actual bug in the system, that led this property to fail for some very rare executions. Although this buggy behavior would be observed from time to time during stress testing, there was no way to reproduce the bug until we tested vNext using the \psharp systematic testing engine.

\PDComment{Show how we specified the liveness property in vNext?}

\subsection{Handling intra-machine concurrency}
\label{sec:psharp:async}

Vanilla \psharp is able to capture and take control of the \emph{inter-machine concurrency} due to message passing, but is unable to systematically explore any interleavings due to \emph{intra-machine concurrency} (e.g. async/await or TPL). This is problematic as nowadays, with multicore machines being a commodity, programmers tend to write multithreaded code to exploit shared memory architectures and increase the performance of individual components of a distributed system.

As an example, the Live Azure Migration system uses the \texttt{async} and \texttt{await} \csharp 5.0 language primitives. Asynchronous code using \texttt{async}/\texttt{await} is more readable because it looks like traditional procedural code, but it is translated by the compiler to an event-driven state machine that is built on top of TPL to achieve performance. The key idea behind \texttt{async}/\texttt{await} is that a method declared as \texttt{async} can use internally the \texttt{await} keyword which allows the thread executing the method to wait on a TPL task, or any other \emph{awaitable} object, \emph{without} blocking. This is achieved as follows. When an \texttt{await} statement is executed, the code following the await is wrapped as a TPL task \emph{continuation} and the method returns to the caller. This continuation executes when the awaitable object has completed.

Developing a fully automatic and universal approach to handle intra-machine concurrency in .NET is very challenging, because there are many APIs that can be used for concurrency and synchronization (e.g. \texttt{System.Threading}, TPL, async/await, locks, semaphores) and each one has its own complexities. Although developers are willing to model the top-level message passing communication using \psharp, they are resistant in modeling the low-level threading and synchronization methods as this would be a very invasive procedure and such refactoring is unlikely to scale for legacy code.

To test our case studies, we decided to focus our efforts in handling async/await as providing a robust solution for a subset of the .NET threading APIs is more feasible than trying to handle arbitrary threading and synchronization. Our solution involves using a custom \texttt{TaskScheduler} instead of the default TPL task scheduler. The \texttt{TaskScheduler} class \PDComment{write some stuff}.

Our approach works as follows. We start the task of the \emph{root} \psharp machine in our custom task scheduler. As long as any child tasks spawned by the root machine task do not explicitly start in another scheduler (including the default TPL scheduler), then they will be scheduled for execution in our custom task scheduler. Our custom scheduler intercepts the call to enqueue a task, creates a special machine called \texttt{TaskMachine} and \emph{wraps} the enqueued task inside this machine. The constructor of a \texttt{TaskMachine} takes as an argument a TPL task and stores it in an field. The \texttt{TaskMachine} has only a single state and when it is scheduled for execution by the \psharp systematic testing scheduler it will start executing the wrapped task and then immediately wait on its completion. This forces the lifetime of the task to become the lifetime of the machine and vice versa. Thus, when the \psharp systematic testing scheduler schedules the \texttt{TaskMachine}, it will also schedule the corresponding task. This means that when a \psharp program makes a call to an \texttt{async} method, then the task created in the backend will be automatically wrapped and scheduled.

For \texttt{await} statements, no special treatment is required because \texttt{await} statements are compiled into a continuation. The task associated with the continuation will also be wrapped and scheduled accordingly.
