We compared the bug-finding effectiveness of \psharp systematic concurrency testing to traditional ``stress testing'' without systematic concurrency control on several benchmark bugs, described below.  We report the length of time it took for the test to fail and remark on the effort needed to diagnose the bug from the test output. \MMComment{Overview of actual results?}

\subsection{Experimental Setup}

All experiments were run on \MMComment{insert MSR machine, or perhaps CloudDevR1S04 if John/Matt are able to grant access to the rest of the collaborators}. \MMComment{specs}

\subsection{Benchmarks}

\newcommand{\colspacing}{\hspace{1.8em}}
\begin{table}[t]
\small
\centering
\setlength{\tabcolsep}{0.3em}
\label{tab:stats}
\begin{tabular}{l rrrrr rr}
\centering
\input{experiments/tables/statistics.tex}
\end{tabular}
\caption{Statistics.}
%\vspace{-3mm}
\end{table}

\PDComment{We probably do not need this now that we have many bugs from the case studies -- benchmarks that are not production code (e.g. multipaxos) that can be used to evaluate testing}

Cheng's case study with the actual bug

After fixing all the bugs we found in MigratingTable, we added an option to conditionally reintroduce each of the following bugs:
\begin{enumerate}
\item Filtering on a user-defined property did not retrieve non-matching rows from the new table that might shadow a matching row from the old table.
\item ...
\end{enumerate}

\subsection{Stress testing vs \psharp testing}

\setlength{\tabcolsep}{.42em}
\begin{table*}[t]
\small
\centering
\begin{tabular}{l rr rrrr}
\centering
\input{experiments/tables/results.tex}
\end{tabular}
\caption{Results from 100000 iterations of \psharp random walk scheduler.}
\label{tab:testing}
\end{table*}

Comparison of traditional stress testing VS what we do with \psharp

How long you had to run the test to find the bug (if you can find it) and how long are the traces

How easy it is to pinpoint the error using the \psharp traces, comparing to traditional stress testing

Effort required to use the system

Controlled random scheduling has proven to be efficient for finding concurrency bugs~\cite{thomson2014sct, deligiannis2015psharp}.

\subsection{An example bug in MigratingTable}
\MMComment{Move wherever appropriate}

One of the bugs in MigratingTable that we found using the \psharp test stands out because it reflects the type of oversight that tends to occur as designs evolve and it's unclear whether we would have been able to find it by any other method (\MMComment{revise remark when we have stress test results?}).  This bug, which we named QueryStreamedBackUpNewStream, is in the implementation of a streaming read from the virtual table, which should return a stream of all rows in the table sorted by key.  The essential implementation idea is to start streams $s_O$, $s_N$ from the old and new backend tables and merge the sorted streams by keeping track of the next row in each stream and returning the row with the lesser key.  In parallel, the migrator job is concurrently copying rows from the old table to the new table; we had satisfied ourselves that this concurrency would not cause any problems.  However, then we added support to the migrator job to delete the old table when it finishes copying, which triggers the virtual stream to close $s_O$.  Suppose the virtual stream is in a state in which the next row in $s_O$ has key $k_O$ and the next row in $s_N$ has key $k_N$, where $k_O < k_N$.  Further suppose that before the next read from the virtual stream, the migrator job copies a row with key $k$ ($k_O < k < k_N$) from the old table to the new table and then deletes the old table.  Since $s_O$ has not yet returned this row when it is closed and $s_N$ has already advanced to $k_N$, the row with key $k$ will be missed by the virtual stream.  A similar problem can occur if $s_N$ does not reflect rows inserted into the new table by the migrator job after $s_N$ is started, as allowed by the IChainTable2 specification.  Restarting $s_N$ when the old table is deleted fixes both variants of the bug.

\MMComment{Add a figure based on migration-bug3-explanation.pptx (probably a hybrid of slides 4 and 5, assuming we want only one figure).}
